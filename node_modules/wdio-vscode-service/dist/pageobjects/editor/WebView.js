"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebView = void 0;
const Editor_1 = require("./Editor");
const utils_1 = require("../utils");
const _1_61_0_1 = require("../../locators/1.61.0");
let handle;
/**
 * Page object representing an open editor containing a web view
 *
 * @category Editor
 */
let WebView = class WebView extends Editor_1.Editor {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'WebView';
    }
    /**
     * Search for an element inside the webview iframe.
     * Requires webdriver being switched to the webview iframe first.
     * (Will attempt to search from the main DOM root otherwise)
     *
     * @param locator webdriver locator to search by
     * @returns promise resolving to WebElement when found
     */
    async findWebElement(locator) {
        return this.elem.$(locator);
    }
    /**
     * Search for all element inside the webview iframe by a given locator
     * Requires webdriver being switched to the webview iframe first.
     * (Will attempt to search from the main DOM root otherwise)
     *
     * @param locator webdriver locator to search by
     * @returns promise resolving to a list of WebElement objects
     */
    async findWebElements(locator) {
        return this.elem.$$(locator);
    }
    /**
     * Switch the underlying webdriver context to the webview iframe.
     * This allows using the findWebElement methods.
     * Note that only elements inside the webview iframe will be accessible.
     * Use the switchBack method to switch to the original context.
     */
    async switchToFrame() {
        if (!handle) {
            handle = await browser.getWindowHandle();
        }
        const handles = await browser.getWindowHandles();
        for (const h of handles) {
            await browser.switchToWindow(h);
            if ((await browser.getTitle()).includes('Virtual Document')) {
                await browser.switchToFrame(0);
                return;
            }
        }
        await browser.switchToWindow(handle);
        const reference = await this.elem.$(this.locatorMap.EditorView.webView);
        const flowToAttr = await reference.getAttribute('aria-flowto');
        const container = await browser.$(`#${flowToAttr}`);
        await container.waitForExist({ timeout: 5000 });
        let tries = [];
        await browser.waitUntil(async () => {
            tries = await container.$$(this.locators.iframe);
            if (tries.length > 0) {
                return true;
            }
            return false;
        }, { timeout: 5000 });
        const view = tries[0];
        await browser.switchToFrame(view);
        const frame = await this.activeFrame$;
        await frame.waitForExist({ timeout: 5000 });
        await browser.switchToFrame(frame);
    }
    /**
     * Switch the underlying webdriver back to the original window
     */
    async switchBack() {
        if (!handle) {
            handle = await browser.getWindowHandle();
        }
        return browser.switchToWindow(handle);
    }
};
WebView = __decorate([
    (0, utils_1.PluginDecorator)(_1_61_0_1.WebView)
], WebView);
exports.WebView = WebView;
//# sourceMappingURL=WebView.js.map